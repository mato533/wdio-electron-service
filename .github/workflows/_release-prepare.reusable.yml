name: Prepare Release

on:
  workflow_call:
    inputs:
      target_branch:
        description: 'Target branch to prepare release from'
        required: true
        type: string
      next_lts_branch:
        description: 'Next LTS branch name'
        required: true
        type: string
      release_version:
        description: 'Release type (patch, minor, major, prepatch, preminor, premajor, prerelease)'
        required: true
        type: string
      dry_run:
        description: 'Do not touch or write anything. Show the commands.'
        required: true
        default: false
        type: boolean
      branch_type:
        description: 'Branch type (main, feature, maintenance)'
        required: true
        type: string
    secrets:
      github_bot_token:
        description: 'GitHub token for authentication'
        required: true
      deploy_key:
        description: 'SSH deploy key for pushing to the repository'
        required: true
    outputs:
      version:
        description: 'The new version number'
        value: ${{ jobs.prepare.outputs.version }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version_bump.outputs.version }}
    steps:
      - name: üë∑ Checkout target branch
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.deploy_key }}
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0 # Full history needed for versioning

      - name: üõ†Ô∏è Setup workspace
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: '20'

      - name: üèóÔ∏è Build packages
        uses: ./.github/workflows/actions/build-verify

      - name: üîÑ Update dependabot configuration
        # Update dependabot config for major releases, but not for prereleases
        if: ${{ contains(inputs.release_version, 'major') && !contains(inputs.release_version, 'pre') }}
        shell: bash
        env:
          NEW_LTS_BRANCH: ${{ inputs.next_lts_branch }}
          CONFIG_DEPENDABOT: '.github/dependabot.yml'
        run: |
          echo '::group::Updating the configuration of dependabot'
          # Update the target-branch in dependabot.yml to point to the new LTS branch
          yq e "(.. | select(has(\"target-branch\"))
                    | select(.[\"target-branch\"]
                    | test(\"^v[0-9]+$\"))).target-branch = \"${NEW_LTS_BRANCH}\"" \
            -i "${CONFIG_DEPENDABOT}"

          if git diff --exit-code --quiet "${CONFIG_DEPENDABOT}"; then
            echo "No changes detected."
            exit 0
          fi

          echo "Update branch name for LTS(New value: ${NEW_LTS_BRANCH})."
          git diff "${CONFIG_DEPENDABOT}"
          echo '::endgroup::'

          echo '::group::Committing changes'
          git add "${CONFIG_DEPENDABOT}"
          git commit -F-<<EOF
          chore: update dependabot.yml

          Update branch name for LTS (new value: ${NEW_LTS_BRANCH})
          [skip ci]
          EOF
          git show
          echo '::endgroup::'

      - name: üè∑Ô∏è Bump Version
        id: version_bump
        # Uses turbo-version to bump versions but don't create git tags yet
        run: |
          # Bump version but don't create tag yet
          pnpm turbo-version -b ${{ inputs.release_version }} --no-tag

          # Get the new version
          VERSION=$(jq -r '.version' packages/wdio-electron-service/package.json)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "New version: ${VERSION}"

      - name: üìù Commit version changes
        shell: bash
        run: |
          git add .
          git commit -m "chore: bump version to ${{ steps.version_bump.outputs.version }} [skip ci]"

      - name: üîÄ Push changes to original branch
        if: ${{ !inputs.dry_run }}
        shell: bash
        run: |
          git push origin ${{ inputs.target_branch }}

      - name: üîÄ Merge to Main (if needed)
        if: ${{ !inputs.dry_run && inputs.branch_type != 'main' && inputs.branch_type != 'maintenance' }}
        shell: bash
        env:
          TARGET_BRANCH: ${{ inputs.target_branch }}
          VERSION: ${{ steps.version_bump.outputs.version }}
        run: |
          echo "::group::Merging to main for release"

          # Checkout main
          git checkout main
          git pull origin main

          # Try to merge the target branch into main
          echo "Merging ${TARGET_BRANCH} into main..."
          if ! git merge --no-ff ${TARGET_BRANCH} -m "chore: merge ${TARGET_BRANCH} for v${VERSION} release [skip ci]"; then
            echo "::error::Merge conflict detected when merging ${TARGET_BRANCH} to main"
            git merge --abort
            echo "Please resolve conflicts manually and try again"
            exit 1
          fi

          # Push the merge to main
          git push origin main

          echo "::endgroup::"

      - name: üìã Log changes (dry run only)
        if: ${{ inputs.dry_run }}
        env:
          RELEASE_BRANCH: ${{ inputs.target_branch }}
        run: |
          git diff "origin/${RELEASE_BRANCH}"
          echo "DRY RUN: No changes were made."
